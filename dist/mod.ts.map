{
  "version": 3,
  "sources": ["../urn.ts", "../triples.ts", "../sets.ts", "../metrics.ts", "../triple-index.ts", "../tribble-db.ts"],
  "sourcesContent": ["/*\n * URNs in this library follow the schema:\n *\n *   urn:<namespace>:<type>:<id>[?<querystring>]\n *\n * Information can be contextualised by query-string. E.g (in triple format)\n *\n *   [\"urn:r\u00F3:bird:apus-apus?photo=123\", \"in-flight\", \"true\"]\n *\n * Any triples matching this specification will have the relation-target applied semantically. E.g\n *\n *   urn:r\u00F3:bird:apus-apus?photo=123&context=captivity\n *\n * matches\n *\n *   urn:r\u00F3:bird:apus-apus\n *\n * does not. The pattern\n *\n *   [\"urn:r\u00F3:bird:apus-apus\", \"name\", \"Swift\"]\n *\n * matches all swifts, regardless of query parameters.\n */\n\nimport type { ParsedUrn } from \"./types.ts\";\n\n/*\n * Parses a URN string into its components.\n *\n * @param urn - The URN string to parse.\n * @param namespace - The namespace to use (default: \"r\u00F3\").\n * @returns The parsed URN components.\n */\nexport function parseUrn(urn: string, namespace: string = \"r\u00F3\"): ParsedUrn {\n  if (!urn.startsWith(`urn:${namespace}:`)) {\n    throw new Error(`Invalid URN for namespace ${namespace}: ${urn}`);\n  }\n\n  const type = urn.split(\":\")[2];\n  const [urnPart, queryString] = urn.split(\"?\");\n  const id = urnPart.split(\":\")[3];\n  const qs = queryString\n    ? Object.fromEntries(new URLSearchParams(queryString))\n    : {};\n\n  return {\n    type,\n    id,\n    qs,\n  };\n}\n\n/*\n * Converts a string value to a URN.\n */\nexport function asUrn(value: string, namespace: string = \"r\u00F3\"): ParsedUrn {\n  try {\n    return parseUrn(value, namespace);\n  } catch (_) {\n    return {\n      type: \"unknown\",\n      id: value,\n      qs: {},\n    };\n  }\n}\n", "import type { Triple } from \"./types.ts\";\n\n/*\n * Static methods for interacting with triples.\n */\nexport class Triples {\n  static source(triple: Triple): string {\n    return triple[0];\n  }\n\n  static relation(triple: Triple): string {\n    return triple[1];\n  }\n\n  static target(triple: Triple): string {\n    return triple[2];\n  }\n}\n", "import { TribbleDBPerformanceMetrics } from \"./metrics.ts\";\n\n/*\n * Indexed set class\n *\n * Allows you to check content membership in O(1), and lookup by key or index in O(1).\n *\n * Used to address content to unique IDs, to waste less memory during indexing.\n */\nexport class IndexedSet {\n  #idx: number;\n  #map: Map<string, number>;\n  #reverseMap: Map<number, string>;\n\n  constructor() {\n    this.#idx = 0;\n    this.#map = new Map();\n    this.#reverseMap = new Map();\n  }\n\n  map() {\n    return this.#map;\n  }\n\n  reverseMap() {\n    return this.#reverseMap;\n  }\n\n  add(value: string) {\n    if (this.#map.has(value)) {\n      return this.#map.get(value)!;\n    }\n\n    this.#map.set(value, this.#idx);\n    this.#reverseMap.set(this.#idx, value);\n    this.#idx++;\n\n    return this.#idx - 1;\n  }\n\n  getIndex(value: string): number | undefined {\n    return this.#map.get(value);\n  }\n\n  getValue(idx: number): string | undefined {\n    return this.#reverseMap.get(idx);\n  }\n\n  has(value: string): boolean {\n    return this.#map.has(value);\n  }\n}\n\nexport class Sets {\n  /*\n   * Compute the intersection of multiple numeric sets.\n   * The number of sets will be low (we're not adding ninety\n   * query parameters to these URNs) so first sort the\n   * sets in ascending size. This could be done much, much more\n   * efficiently with a dataset that allows cheap intersections though...TODO\n   */\n  static intersection<T>(metrics: TribbleDBPerformanceMetrics, sets: Set<T>[]): Set<T> {\n    if (sets.length === 0) {\n      return new Set<T>();\n    }\n\n    sets.sort((setA, setB) => {\n      return setA.size - setB.size;\n    });\n    const acc = new Set<T>(sets[0]);\n\n    for (let idx = 1; idx < sets.length; idx++) {\n      const currentSet = sets[idx];\n      for (const value of acc) {\n        metrics.setCheck();\n        if (!currentSet.has(value)) {\n          acc.delete(value);\n        }\n      }\n\n      if (acc.size === 0) {\n        break;\n      }\n    }\n\n    return acc;\n  }\n}\n", "\nexport class IndexPerformanceMetrics {\n  mapReadCount: number;\n\n  constructor() {\n    this.mapReadCount = 0;\n  }\n\n  mapRead() {\n    this.mapReadCount++;\n  }\n}\n\nexport class TribbleDBPerformanceMetrics {\n  setCheckCount: number;\n\n  constructor() {\n    this.setCheckCount = 0\n  }\n\n  setCheck() {\n    this.setCheckCount++;\n  }\n}\n", "import { Triples } from \"./triples.ts\";\nimport type { IndexedTriple, Triple } from \"./types.ts\";\nimport { asUrn } from \"./urn.ts\";\nimport { IndexedSet } from \"./sets.ts\";\nimport { IndexPerformanceMetrics } from \"./metrics.ts\";\n\n/*\n * Construct an index to accelerate triple searches. Normally\n * search would be done through a linear table scan, but it can\n * be sped up by mapping each queryable term (e.g `source.id`) to\n * a set of indices of triples which match this term.\n *\n * This implementation uses IndexedSet to map strings to numbers\n * internally for better memory efficiency with long strings.\n */\nexport class Index {\n  // Internal indexed representation for memory efficiency\n  private indexedTriples: IndexedTriple[];\n\n  // String indexing sets for memory efficiency\n  private stringIndex: IndexedSet;\n\n  sourceType: Map<number, Set<number>>;\n  sourceId: Map<number, Set<number>>;\n  // note: QS uses a composite key: <key>=<value>\n  sourceQs: Map<number, Set<number>>;\n\n  relations: Map<number, Set<number>>;\n\n  targetType: Map<number, Set<number>>;\n  targetId: Map<number, Set<number>>;\n  targetQs: Map<number, Set<number>>;\n\n  metrics: IndexPerformanceMetrics;\n\n  constructor(triples: Triple[]) {\n    this.indexedTriples = [];\n    this.stringIndex = new IndexedSet();\n\n    this.sourceType = new Map();\n    this.sourceId = new Map();\n    this.sourceQs = new Map();\n    this.relations = new Map();\n    this.targetType = new Map();\n    this.targetId = new Map();\n    this.targetQs = new Map();\n    this.indexTriples(triples);\n    this.metrics = new IndexPerformanceMetrics();\n  }\n\n  /*\n   * Associate each triple onto an appropriate map `Term := <id>: <value>`\n   */\n  indexTriples(triples: Triple[]) {\n    for (let idx = 0; idx < triples.length; idx++) {\n      this.indexTriple(triples[idx], idx);\n    }\n  }\n\n  /*\n   * Index a single triple at the given index position\n   */\n  private indexTriple(triple: Triple, idx: number) {\n    const parsedSource = asUrn(Triples.source(triple));\n    const relation = Triples.relation(triple);\n    const parsedTarget = asUrn(Triples.target(triple));\n\n    // Convert strings to indices using the IndexedSet\n    const sourceTypeIdx = this.stringIndex.add(parsedSource.type);\n    const sourceIdIdx = this.stringIndex.add(parsedSource.id);\n    const relationIdx = this.stringIndex.add(relation);\n    const targetTypeIdx = this.stringIndex.add(parsedTarget.type);\n    const targetIdIdx = this.stringIndex.add(parsedTarget.id);\n\n    // Store the indexed triple\n    this.indexedTriples.push([\n      this.stringIndex.add(Triples.source(triple)),\n      relationIdx,\n      this.stringIndex.add(Triples.target(triple)),\n    ]);\n\n    // source.type\n    if (!this.sourceType.has(sourceTypeIdx)) {\n      this.sourceType.set(sourceTypeIdx, new Set());\n    }\n    this.sourceType.get(sourceTypeIdx)!.add(idx);\n\n    // source.id\n    if (!this.sourceId.has(sourceIdIdx)) {\n      this.sourceId.set(sourceIdIdx, new Set());\n    }\n    this.sourceId.get(sourceIdIdx)!.add(idx);\n\n    // source.qs\n    for (const [key, val] of Object.entries(parsedSource.qs)) {\n      const qsIdx = this.stringIndex.add(`${key}=${val}`);\n      if (!this.sourceQs.has(qsIdx)) {\n        this.sourceQs.set(qsIdx, new Set());\n      }\n\n      this.sourceQs.get(qsIdx)!.add(idx);\n    }\n\n    // relation\n    if (!this.relations.has(relationIdx)) {\n      this.relations.set(relationIdx, new Set());\n    }\n    this.relations.get(relationIdx)!.add(idx);\n\n    // target.type\n    if (!this.targetType.has(targetTypeIdx)) {\n      this.targetType.set(targetTypeIdx, new Set());\n    }\n    this.targetType.get(targetTypeIdx)!.add(idx);\n\n    // target.id\n    if (!this.targetId.has(targetIdIdx)) {\n      this.targetId.set(targetIdIdx, new Set());\n    }\n    this.targetId.get(targetIdIdx)!.add(idx);\n\n    // target.qs\n    for (const [key, val] of Object.entries(parsedTarget.qs)) {\n      const qsIdx = this.stringIndex.add(`${key}=${val}`);\n      if (!this.targetQs.has(qsIdx)) {\n        this.targetQs.set(qsIdx, new Set());\n      }\n\n      this.targetQs.get(qsIdx)!.add(idx);\n    }\n  }\n\n  /*\n   * Add new triples to the index incrementally\n   */\n  add(newTriples: Triple[]) {\n    const startIdx = this.indexedTriples.length;\n\n    // Index the new triples\n    for (let idx = 0; idx < newTriples.length; idx++) {\n      this.indexTriple(newTriples[idx], startIdx + idx);\n    }\n  }\n\n  /*\n   * Get the number of triples in the index\n   */\n  get length(): number {\n    return this.indexedTriples.length;\n  }\n\n  /*\n   * Reconstruct the original triples from the indexed representation\n   */\n  triples(): Triple[] {\n    return this.indexedTriples.map(([sourceIdx, relationIdx, targetIdx]) => [\n      this.stringIndex.getValue(sourceIdx)!,\n      this.stringIndex.getValue(relationIdx)!,\n      this.stringIndex.getValue(targetIdx)!,\n    ]);\n  }\n\n  /*\n   * Get a specific triple by index\n   */\n  getTriple(index: number): Triple | undefined {\n    if (index < 0 || index >= this.indexedTriples.length) {\n      return undefined;\n    }\n\n    const [sourceIdx, relationIdx, targetIdx] = this.indexedTriples[index];\n    return [\n      this.stringIndex.getValue(sourceIdx)!,\n      this.stringIndex.getValue(relationIdx)!,\n      this.stringIndex.getValue(targetIdx)!,\n    ];\n  }\n\n  /*\n   * Helper methods to convert string keys to indices for external API compatibility\n   */\n\n  getSourceTypeSet(type: string): Set<number> | undefined {\n    const typeIdx = this.stringIndex.getIndex(type);\n\n    if (typeIdx === undefined) {\n      return undefined;\n    }\n    this.metrics.mapRead();\n\n    return this.sourceType.get(typeIdx);\n  }\n\n  getSourceIdSet(id: string): Set<number> | undefined {\n    const idIdx = this.stringIndex.getIndex(id);\n\n    if (idIdx === undefined) {\n      return undefined;\n    }\n    this.metrics.mapRead();\n\n    return this.sourceId.get(idIdx);\n  }\n\n  getSourceQsSet(key: string, val: string): Set<number> | undefined {\n    const qsIdx = this.stringIndex.getIndex(`${key}=${val}`);\n\n    if (qsIdx === undefined) {\n      return undefined;\n    }\n    this.metrics.mapRead();\n\n    return this.sourceQs.get(qsIdx);\n  }\n\n  getRelationSet(relation: string): Set<number> | undefined {\n    const relationIdx = this.stringIndex.getIndex(relation);\n\n    if (relationIdx === undefined) {\n      return undefined;\n    }\n    this.metrics.mapRead();\n\n    return this.relations.get(relationIdx);\n  }\n\n  getTargetTypeSet(type: string): Set<number> | undefined {\n    const typeIdx = this.stringIndex.getIndex(type);\n\n    if (typeIdx === undefined) {\n      return undefined;\n    }\n    this.metrics.mapRead();\n\n    return this.targetType.get(typeIdx);\n  }\n\n  getTargetIdSet(id: string): Set<number> | undefined {\n    const idIdx = this.stringIndex.getIndex(id);\n    if (idIdx === undefined) {\n      return undefined;\n    }\n    this.metrics.mapRead();\n    return this.targetId.get(idIdx);\n  }\n\n  getTargetQsSet(key: string, val: string): Set<number> | undefined {\n    const qsIdx = this.stringIndex.getIndex(`${key}=${val}`);\n    if (qsIdx === undefined) {\n      return undefined;\n    }\n    this.metrics.mapRead();\n    return this.targetQs.get(qsIdx);\n  }\n}\n", "import type { Dsl, Triple, TripleObject } from \"./types.ts\";\nimport { Index } from \"./triple-index.ts\";\nimport { Sets } from \"./sets.ts\";\nimport { Triples } from \"./triples.ts\";\nimport { TribbleDBPerformanceMetrics } from \"./metrics.ts\";\n\n/*\n * A searchable triple database\n *\n * Provides methods for adding, searching, and manipulating triples.\n */\nexport class TribbleDB {\n  index: Index;\n  triplesCount: number;\n  tripleRows: Set<number>;\n  metrics: TribbleDBPerformanceMetrics;\n\n  constructor(triples: Triple[]) {\n    this.index = new Index(triples);\n    this.triplesCount = this.index.length;\n    this.tripleRows = new Set<number>();\n    this.metrics = new TribbleDBPerformanceMetrics();\n\n    for (let idx = 0; idx < this.triplesCount; idx++) {\n      this.tripleRows.add(idx);\n    }\n  }\n\n  static of(triples: Triple[]): TribbleDB {\n    return new TribbleDB(triples);\n  }\n\n  /*\n   * Convert an array of TripleObject instances to a TribbleDB.\n   *\n   * @param objects - An array of TripleObject instances.\n   *\n   * @returns A TribbleDB instance.\n   */\n  static from(objects: TripleObject[]): TribbleDB {\n    const triples: Triple[] = [];\n\n    for (const obj of objects) {\n      const { id, ...relations } = obj;\n      if (typeof id !== \"string\") {\n        throw new Error(\"Each TripleObject must have a string id.\");\n      }\n\n      for (const [relation, target] of Object.entries(relations)) {\n        if (Array.isArray(target)) {\n          for (const sub of target) {\n            triples.push([id, relation, sub]);\n          }\n        } else {\n          triples.push([id, relation, target]);\n        }\n      }\n    }\n\n    return new TribbleDB(triples);\n  }\n\n  /**\n   * Add new triples to the database.\n   *\n   * @param triples - An array of triples to add.\n   */\n  add(triples: Triple[]): void {\n    const oldLength = this.index.length;\n\n    this.index.add(triples);\n    this.triplesCount = this.index.length;\n\n    for (let idx = oldLength; idx < this.triplesCount; idx++) {\n      this.tripleRows.add(idx);\n    }\n  }\n\n  /**\n   * Map over the triples in the database.\n   *\n   * @param fn - A mapping function.\n   * @returns A new TribbleDB instance containing the mapped triples.\n   */\n  map(fn: (triple: Triple) => Triple): TribbleDB {\n    return new TribbleDB(this.index.triples().map(fn));\n  }\n\n  /**\n   * Flat map over the triples in the database.\n   *\n   * @param fn - A mapping function.\n   * @returns A new TribbleDB instance containing the flat-mapped triples.\n   */\n  flatMap(fn: (triple: Triple) => Triple[]): TribbleDB {\n    const flatMappedTriples = this.index.triples().flatMap(fn) as Triple[];\n    return new TribbleDB(flatMappedTriples);\n  }\n\n  /**\n   * Get the first triple in the database.\n   *\n   * @returns The first triple, or undefined if there are no triples.\n   */\n  firstTriple(): Triple | undefined {\n    return this.index.length > 0 ? this.index.getTriple(0) : undefined;\n  }\n\n  /*\n   * Get the first source in the database.\n   */\n  firstSource(): string | undefined {\n    const first = this.firstTriple();\n    return first ? Triples.source(first) : undefined;\n  }\n\n  /**\n   * Get the first relation in the database.\n   */\n  firstRelation(): string | undefined {\n    const first = this.firstTriple();\n    return first ? Triples.relation(first) : undefined;\n  }\n\n  /**\n   * Get the first target in the database.\n   */\n  firstTarget(): string | undefined {\n    const first = this.firstTriple();\n    return first ? Triples.target(first) : undefined;\n  }\n\n  /*\n   * Get the first object in the database.\n   */\n  firstObject(listOnly: boolean = false): TripleObject | undefined {\n    return this.objects(listOnly)[0];\n  }\n\n  /*\n   * Get all triples in the database.\n   *\n   * @returns An array of all triples.\n   */\n  triples(): Triple[] {\n    return this.index.triples();\n  }\n\n  /**\n   * Get all unique sources in the database.\n   *\n   * @returns A set of all unique sources.\n   */\n  sources(): Set<string> {\n    return new Set(\n      this.index.triples().map(Triples.source),\n    );\n  }\n\n  /**\n   * Get all unique relations in the database.\n   *\n   * @returns A set of all unique relations.\n   */\n  relations(): Set<string> {\n    return new Set(\n      this.index.triples().map(Triples.relation),\n    );\n  }\n\n  /**\n   * Get all unique targets in the database.\n   *\n   * @returns A set of all unique targets.\n   */\n  targets(): Set<string> {\n    return new Set(\n      this.index.triples().map(Triples.target),\n    );\n  }\n\n  /*\n   * Get all unique objects represented by the triples.\n   *\n   * @returns An array of unique TripleObject instances.\n   */\n  objects(listOnly: boolean = false): TripleObject[] {\n    const objs: Record<string, TripleObject> = {};\n\n    for (const [source, relation, target] of this.index.triples()) {\n      if (!objs[source]) {\n        objs[source] = {};\n      }\n      if (!objs[source][relation]) {\n        objs[source][relation] = listOnly ? [target] : target;\n      } else if (Array.isArray(objs[source][relation])) {\n        (objs[source][relation] as string[]).push(target);\n      } else {\n        objs[source][relation] = [objs[source][relation] as string, target];\n      }\n    }\n\n    const output: TripleObject[] = [];\n\n    for (const [id, obj] of Object.entries(objs)) {\n      obj.id = id;\n      output.push(obj);\n    }\n\n    return output;\n  }\n\n  /*\n   * Search all triples in the database.\n   *\n   * @param params - The search parameters.\n   * @returns A new TribbleDB instance containing the matching triples.\n   */\n  search(\n    params: { source?: Dsl; relation?: string; target?: Dsl },\n  ): TribbleDB {\n    // by default, all triples are in the intersection set. Then, we\n    // only keep the triple rows that meet the other criteria too, by\n    // insecting all row sets.\n    const matchingRowSets: Set<number>[] = [\n      this.tripleRows,\n    ];\n\n    const { source, relation, target } = params;\n\n    if (source) {\n      if (source.type) {\n        const sourceTypeSet = this.index.getSourceTypeSet(source.type);\n        if (sourceTypeSet) {\n          matchingRowSets.push(sourceTypeSet);\n        } else {\n          return new TribbleDB([]);\n        }\n      }\n\n      if (source.id) {\n        const sourceIdSet = this.index.getSourceIdSet(source.id);\n        if (sourceIdSet) {\n          matchingRowSets.push(sourceIdSet);\n        } else {\n          return new TribbleDB([]);\n        }\n      }\n\n      if (source.qs) {\n        for (const [key, val] of Object.entries(source.qs)) {\n          const sourceQsSet = this.index.getSourceQsSet(key, val);\n          if (sourceQsSet) {\n            matchingRowSets.push(sourceQsSet);\n          } else {\n            return new TribbleDB([]);\n          }\n        }\n      }\n    }\n\n    if (target) {\n      if (target.type) {\n        const targetTypeSet = this.index.getTargetTypeSet(target.type);\n        if (targetTypeSet) {\n          matchingRowSets.push(targetTypeSet);\n        } else {\n          return new TribbleDB([]);\n        }\n      }\n\n      if (target.id) {\n        const targetIdSet = this.index.getTargetIdSet(target.id);\n        if (targetIdSet) {\n          matchingRowSets.push(targetIdSet);\n        } else {\n          return new TribbleDB([]);\n        }\n      }\n\n      if (target.qs) {\n        for (const [key, val] of Object.entries(target.qs)) {\n          const targetQsSet = this.index.getTargetQsSet(key, val);\n          if (targetQsSet) {\n            matchingRowSets.push(targetQsSet);\n          } else {\n            return new TribbleDB([]);\n          }\n        }\n      }\n    }\n\n    if (relation) {\n      const relationSet = this.index.getRelationSet(relation);\n      if (relationSet) {\n        matchingRowSets.push(relationSet);\n      } else {\n        return new TribbleDB([]);\n      }\n    }\n\n    const intersection = Sets.intersection(this.metrics, matchingRowSets);\n    const matchingTriples: Triple[] = [];\n\n    // Collect matching triples, applying predicate filters as we go\n    for (const index of intersection) {\n      const triple = this.index.getTriple(index)!;\n\n      if (!source?.predicate && !target?.predicate) {\n        matchingTriples.push(triple);\n        continue;\n      }\n\n      let isValid = true;\n\n      if (source?.predicate) {\n        isValid = isValid && source.predicate(Triples.source(triple));\n      }\n\n      if (target?.predicate) {\n        isValid = isValid && target.predicate(Triples.target(triple));\n      }\n\n      if (isValid) {\n        matchingTriples.push(triple);\n      }\n    }\n\n    return new TribbleDB(matchingTriples);\n  }\n\n  getMetrics() {\n    return {\n      index: this.index.metrics,\n      db: this.metrics\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["parseUrn", "urn", "namespace", "type", "urnPart", "queryString", "id", "qs", "asUrn", "value", "Triples", "triple", "IndexedSet", "#idx", "#map", "#reverseMap", "value", "idx", "Sets", "metrics", "sets", "setA", "setB", "acc", "currentSet", "IndexPerformanceMetrics", "TribbleDBPerformanceMetrics", "Index", "triples", "IndexedSet", "IndexPerformanceMetrics", "idx", "triple", "parsedSource", "asUrn", "Triples", "relation", "parsedTarget", "sourceTypeIdx", "sourceIdIdx", "relationIdx", "targetTypeIdx", "targetIdIdx", "key", "val", "qsIdx", "newTriples", "startIdx", "sourceIdx", "targetIdx", "index", "type", "typeIdx", "id", "idIdx", "TribbleDB", "_TribbleDB", "triples", "Index", "TribbleDBPerformanceMetrics", "idx", "objects", "obj", "id", "relations", "relation", "target", "sub", "oldLength", "fn", "flatMappedTriples", "first", "Triples", "listOnly", "objs", "source", "output", "params", "matchingRowSets", "sourceTypeSet", "sourceIdSet", "key", "val", "sourceQsSet", "targetTypeSet", "targetIdSet", "targetQsSet", "relationSet", "intersection", "Sets", "matchingTriples", "index", "triple", "isValid"]
}
