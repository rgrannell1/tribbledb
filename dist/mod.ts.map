{
  "version": 3,
  "sources": ["../urn.ts", "../indices/index.ts", "../indices/sets.ts", "../index.ts"],
  "sourcesContent": ["/*\n * URNs in this library follow the schema:\n *\n *   urn:<namespace>:<type>:<id>[?<querystring>]\n *\n * Information can be contextualised by query-string. E.g (in triple format)\n *\n *   [\"urn:r\u00F3:bird:apus-apus?photo=123\", \"in-flight\", \"true\"]\n *\n * Any triples matching this specification will have the relation-target applied semantically. E.g\n *\n *   urn:r\u00F3:bird:apus-apus?photo=123&context=captivity\n *\n * matches\n *\n *   urn:r\u00F3:bird:apus-apus\n *\n * does not. The pattern\n *\n *   [\"urn:r\u00F3:bird:apus-apus\", \"name\", \"Swift\"]\n *\n * matches all swifts, regardless of query parameters.\n */\n\nimport type { ParsedUrn } from \"./types.ts\";\n\n/*\n * Parses a URN string into its components.\n *\n * @param urn - The URN string to parse.\n * @param namespace - The namespace to use (default: \"r\u00F3\").\n * @returns The parsed URN components.\n */\nexport function parseUrn(urn: string, namespace: string = \"r\u00F3\"): ParsedUrn {\n  if (!urn.startsWith(`urn:${namespace}:`)) {\n    throw new Error(`Invalid URN for namespace ${namespace}: ${urn}`);\n  }\n\n  const type = urn.split(\":\")[2];\n  const [urnPart, queryString] = urn.split(\"?\");\n  const id = urnPart.split(\":\")[3];\n  const qs = queryString\n    ? Object.fromEntries(new URLSearchParams(queryString))\n    : {};\n\n  return {\n    type,\n    id,\n    qs,\n  };\n}\n\n/*\n * Converts a string value to a URN.\n */\nexport function asUrn(value: string, namespace: string = \"r\u00F3\"): ParsedUrn {\n  try {\n    return parseUrn(value, namespace);\n  } catch (_) {\n    return {\n      type: \"unknown\",\n      id: value,\n      qs: {},\n    };\n  }\n}\n", "import { Triples } from \"../index.ts\";\nimport type { Triple } from \"../types.ts\";\nimport { asUrn } from \"../urn.ts\";\n\n/*\n * Construct an index to accelerate triple searches. Normally\n * search would be done through a linear table scan, but it can\n * be sped up by mapping each queryable term (e.g `source.id`) to\n * a set of indices of triples which match this term.\n */\nexport class Index {\n  triples: Triple[];\n\n  sourceType: Map<string, Set<number>>;\n  sourceId: Map<string, Set<number>>;\n  // note: QS uses a composite key: <key>=<value>\n  sourceQs: Map<string, Set<number>>;\n\n  relations: Map<string, Set<number>>;\n\n  targetType: Map<string, Set<number>>;\n  targetId: Map<string, Set<number>>;\n  targetQs: Map<string, Set<number>>;\n\n  constructor(triples: Triple[]) {\n    this.triples = triples;\n    this.sourceType = new Map();\n    this.sourceId = new Map();\n    this.sourceQs = new Map();\n    this.relations = new Map();\n    this.targetType = new Map();\n    this.targetId = new Map();\n    this.targetQs = new Map();\n    this.indexTriples();\n  }\n\n  /*\n   * Associate each triple onto an appropriate map `Term := <id>: <value>`\n   */\n  indexTriples() {\n    for (let idx = 0; idx < this.triples.length; idx++) {\n      this.indexTriple(this.triples[idx], idx);\n    }\n  }\n\n  /*\n   * Index a single triple at the given index position\n   */\n  private indexTriple(triple: Triple, idx: number) {\n    const parsedSource = asUrn(Triples.source(triple));\n    const relation = Triples.relation(triple);\n    const parsedTarget = asUrn(Triples.target(triple));\n\n    // source.type\n    if (!this.sourceType.has(parsedSource.type)) {\n      this.sourceType.set(parsedSource.type, new Set());\n    }\n    this.sourceType.get(parsedSource.type)!.add(idx);\n\n    // source.id\n    if (!this.sourceId.has(parsedSource.id)) {\n      this.sourceId.set(parsedSource.id, new Set());\n    }\n    this.sourceId.get(parsedSource.id)!.add(idx);\n\n    // source.qs\n    for (const [key, val] of Object.entries(parsedSource.qs)) {\n      if (!this.sourceQs.has(`${key}=${val}`)) {\n        this.sourceQs.set(`${key}=${val}`, new Set());\n      }\n\n      this.sourceQs.get(`${key}=${val}`)!.add(idx);\n    }\n\n    // relation\n    if (!this.relations.has(relation)) {\n      this.relations.set(relation, new Set());\n    }\n    this.relations.get(relation)!.add(idx);\n\n    // target.type\n    if (!this.targetType.has(parsedTarget.type)) {\n      this.targetType.set(parsedTarget.type, new Set());\n    }\n    this.targetType.get(parsedTarget.type)!.add(idx);\n    // target.id\n    if (!this.targetId.has(parsedTarget.id)) {\n      this.targetId.set(parsedTarget.id, new Set());\n    }\n    this.targetId.get(parsedTarget.id)!.add(idx);\n    // target.qs\n    for (const [key, val] of Object.entries(parsedTarget.qs)) {\n      if (!this.targetQs.has(`${key}=${val}`)) {\n        this.targetQs.set(`${key}=${val}`, new Set());\n      }\n\n      this.targetQs.get(`${key}=${val}`)!.add(idx);\n    }\n  }\n\n  /*\n   * Add new triples to the index incrementally\n   */\n  add(newTriples: Triple[]) {\n    const startIdx = this.triples.length;\n    this.triples.push(...newTriples);\n\n    // Index only the new triples\n    for (let idx = 0; idx < newTriples.length; idx++) {\n      this.indexTriple(newTriples[idx], startIdx + idx);\n    }\n  }\n}\n", "/*\n * Indexed set class\n *\n * Allows you to check content membership in O(1), and lookup by key or index in O(1).\n *\n * Used to address content to unique IDs, to waste less memory during indexing.\n */\nexport class IndexedSet {\n  #idx: number;\n  #map: Map<string, number>;\n  #reverseMap: Map<number, string>;\n\n  constructor() {\n    this.#idx = 0;\n    this.#map = new Map();\n    this.#reverseMap = new Map();\n  }\n\n  map() {\n    return this.#map;\n  }\n\n  reverseMap() {\n    return this.#reverseMap;\n  }\n\n  add(value: string) {\n    if (this.#map.has(value)) {\n      return this.#map.get(value)!;\n    }\n\n    this.#map.set(value, this.#idx);\n    this.#reverseMap.set(this.#idx, value);\n    this.#idx++;\n\n    return this.#idx - 1;\n  }\n\n  getIndex(value: string): number | undefined {\n    return this.#map.get(value);\n  }\n\n  getValue(idx: number): string | undefined {\n    return this.#reverseMap.get(idx);\n  }\n\n  has(value: string): boolean {\n    return this.#map.has(value);\n  }\n}\n\nexport class Sets {\n  /*\n   * Compute the intersection of multiple numeric sets.\n   * The number of sets will be low (we're not adding ninety\n   * query parameters to these URNs) so first sort the\n   * sets in ascending size. This could be done much, much more\n   * efficiently with a dataset that allows cheap intersections though...TODO\n   */\n  static intersection<T>(sets: Set<T>[]): Set<T> {\n    if (sets.length === 0) {\n      return new Set<T>();\n    }\n\n    sets.sort((setA, setB) => {\n      return setA.size - setB.size;\n    });\n    const acc = new Set<T>(sets[0]);\n\n    for (let idx = 1; idx < sets.length; idx++) {\n      const currentSet = sets[idx];\n      for (const value of acc) {\n        if (!currentSet.has(value)) {\n          acc.delete(value);\n        }\n      }\n\n      if (acc.size === 0) {\n        break;\n      }\n    }\n\n    return acc;\n  }\n}\n", "import type { Dsl, Triple, TripleObject } from \"./types.ts\";\nimport { Index } from \"./indices/index.ts\";\nimport { Sets } from \"./indices/sets.ts\";\n\n/*\n * Static methods for interacting with triples.\n */\nexport class Triples {\n  static source(triple: Triple): string {\n    return triple[0];\n  }\n\n  static relation(triple: Triple): string {\n    return triple[1];\n  }\n\n  static target(triple: Triple): string {\n    return triple[2];\n  }\n}\n\n/*\n * A searchable triple database\n *\n * Provides methods for adding, searching, and manipulating triples.\n */\nexport class TribbleDB {\n  index: Index;\n  triplesCount: number;\n\n  constructor(triples: Triple[]) {\n    this.index = new Index(triples);\n    this.triplesCount = triples.length;\n  }\n\n  static of(triples: Triple[]): TribbleDB {\n    return new TribbleDB(triples);\n  }\n\n  static from(objects: TripleObject[]): TribbleDB {\n    const triples: Triple[] = [];\n\n    for (const obj of objects) {\n      const { id, ...relations } = obj;\n\n      for (const [relation, target] of Object.entries(relations)) {\n        if (Array.isArray(target)) {\n          for (const sub of target) {\n            triples.push([id as string, relation, sub]);\n          }\n        } else {\n          triples.push([id as string, relation, target]);\n        }\n      }\n    }\n\n    return new TribbleDB(triples);\n  }\n\n  add(triples: Triple[]): void {\n    this.index.add(triples);\n    this.triplesCount += triples.length;\n  }\n\n  map(fn: (triple: Triple) => Triple): TribbleDB {\n    return new TribbleDB(this.index.triples.map(fn));\n  }\n\n  flatMap(fn: (triple: Triple) => Triple[]): TribbleDB {\n    const flatMappedTriples = this.index.triples.flatMap(fn) as Triple[];\n    return new TribbleDB(flatMappedTriples);\n  }\n\n  first(): Triple | undefined {\n    return this.index.triples.length > 0 ? this.index.triples[0] : undefined;\n  }\n\n  triples(): Triple[] {\n    return this.index.triples;\n  }\n\n  sources(): Set<string> {\n    return new Set(this.index.triples.map((triple) => Triples.source(triple)));\n  }\n\n  relations(): Set<string> {\n    return new Set(\n      this.index.triples.map((triple) => Triples.relation(triple)),\n    );\n  }\n\n  targets(): Set<string> {\n    return new Set(this.index.triples.map((triple) => Triples.target(triple)));\n  }\n\n  /*\n   * Get all unique objects represented by the triples.\n   *\n   * @returns An array of unique TripleObject instances.\n   */\n  objects(): TripleObject[] {\n    const objs: Record<string, TripleObject> = {};\n\n    for (const [source, relation, target] of this.index.triples) {\n      if (!objs[source]) {\n        objs[source] = {};\n      }\n      if (!objs[source][relation]) {\n        objs[source][relation] = target;\n      } else if (Array.isArray(objs[source][relation])) {\n        (objs[source][relation] as string[]).push(target);\n      } else {\n        objs[source][relation] = [objs[source][relation] as string, target];\n      }\n    }\n\n    const output: TripleObject[] = [];\n\n    for (const [id, obj] of Object.entries(objs)) {\n      obj.id = id;\n      output.push(obj);\n    }\n\n    return output;\n  }\n\n  /*\n   * Search all triples in the database.\n   *\n   * @param params - The search parameters.\n   * @returns A new TribbleDB instance containing the matching triples.\n   */\n  search(\n    params: { source?: Dsl; relation?: string; target?: Dsl },\n  ): TribbleDB {\n    // by default, all triples are in the intersection set. Then, we\n    // only keep the triple rows that meet the other criteria too\n    const indexes: Set<number>[] = [\n      new Set<number>(\n        Array.from({ length: this.triplesCount }, (_, index) => index),\n      ),\n    ];\n\n    const source = params.source;\n    const relation = params.relation;\n    const target = params.target;\n\n    if (source) {\n      if (source.type) {\n        const sourceTypeSet = this.index.sourceType.get(source.type);\n        if (sourceTypeSet) {\n          indexes.push(sourceTypeSet);\n        } else {\n          return new TribbleDB([]);\n        }\n      }\n\n      if (source.id) {\n        const sourceIdSet = this.index.sourceId.get(source.id);\n        if (sourceIdSet) {\n          indexes.push(sourceIdSet);\n        } else {\n          return new TribbleDB([]);\n        }\n      }\n\n      if (source.qs) {\n        for (const [key, val] of Object.entries(source.qs)) {\n          const sourceQsSet = this.index.sourceQs.get(`${key}=${val}`);\n          if (sourceQsSet) {\n            indexes.push(sourceQsSet);\n          } else {\n            return new TribbleDB([]);\n          }\n        }\n      }\n    }\n\n    if (target) {\n      if (target.type) {\n        const targetTypeSet = this.index.targetType.get(target.type);\n        if (targetTypeSet) {\n          indexes.push(targetTypeSet);\n        } else {\n          return new TribbleDB([]);\n        }\n      }\n\n      if (target.id) {\n        const targetIdSet = this.index.targetId.get(target.id);\n        if (targetIdSet) {\n          indexes.push(targetIdSet);\n        } else {\n          return new TribbleDB([]);\n        }\n      }\n\n      if (target.qs) {\n        for (const [key, val] of Object.entries(target.qs)) {\n          const targetQsSet = this.index.targetQs.get(`${key}=${val}`);\n          if (targetQsSet) {\n            indexes.push(targetQsSet);\n          } else {\n            return new TribbleDB([]);\n          }\n        }\n      }\n    }\n\n    if (relation) {\n      const relationSet = this.index.relations.get(relation);\n      if (relationSet) {\n        indexes.push(relationSet);\n      } else {\n        return new TribbleDB([]);\n      }\n    }\n\n    const intersection = Sets.intersection(indexes);\n    const matchingTriples: Triple[] = [];\n\n    // Collect matching triples, applying predicate filters as we go\n    for (const index of intersection) {\n      const triple = this.index.triples[index];\n\n      // Apply predicate filters if present\n      if (source?.predicate || target?.predicate) {\n        const sourceMatches = source?.predicate\n          ? source.predicate(Triples.source(triple))\n          : true;\n        const targetMatches = target?.predicate\n          ? target.predicate(Triples.target(triple))\n          : true;\n\n        if (sourceMatches && targetMatches) {\n          matchingTriples.push(triple);\n        }\n      } else {\n        matchingTriples.push(triple);\n      }\n    }\n\n    return new TribbleDB(matchingTriples);\n  }\n\n  searchArray(\n    params: { source?: Dsl; relation?: string; target?: Dsl },\n  ): Triple[] {\n    return this.search(params).triples();\n  }\n}\n"],
  "mappings": "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",
  "names": ["parseUrn", "urn", "namespace", "type", "urnPart", "queryString", "id", "qs", "asUrn", "value", "Index", "triples", "idx", "triple", "parsedSource", "asUrn", "Triples", "relation", "parsedTarget", "key", "val", "newTriples", "startIdx", "Sets", "sets", "setA", "setB", "acc", "idx", "currentSet", "value", "Triples", "triple", "TribbleDB", "_TribbleDB", "triples", "Index", "objects", "obj", "id", "relations", "relation", "target", "sub", "fn", "flatMappedTriples", "objs", "source", "output", "params", "indexes", "_", "index", "sourceTypeSet", "sourceIdSet", "key", "val", "sourceQsSet", "targetTypeSet", "targetIdSet", "targetQsSet", "relationSet", "intersection", "Sets", "matchingTriples", "sourceMatches", "targetMatches"]
}
