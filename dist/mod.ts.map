{
  "version": 3,
  "sources": ["../urn.ts", "../indices/sets.ts", "../indices/index.ts", "../index.ts"],
  "sourcesContent": ["/*\n * URNs in this library follow the schema:\n *\n *   urn:<namespace>:<type>:<id>[?<querystring>]\n *\n * Information can be contextualised by query-string. E.g (in triple format)\n *\n *   [\"urn:r\u00F3:bird:apus-apus?photo=123\", \"in-flight\", \"true\"]\n *\n * Any triples matching this specification will have the relation-target applied semantically. E.g\n *\n *   urn:r\u00F3:bird:apus-apus?photo=123&context=captivity\n *\n * matches\n *\n *   urn:r\u00F3:bird:apus-apus\n *\n * does not. The pattern\n *\n *   [\"urn:r\u00F3:bird:apus-apus\", \"name\", \"Swift\"]\n *\n * matches all swifts, regardless of query parameters.\n */\n\nimport type { ParsedUrn } from \"./types.ts\";\n\n/*\n * Parses a URN string into its components.\n *\n * @param urn - The URN string to parse.\n * @param namespace - The namespace to use (default: \"r\u00F3\").\n * @returns The parsed URN components.\n */\nexport function parseUrn(urn: string, namespace: string = \"r\u00F3\"): ParsedUrn {\n  if (!urn.startsWith(`urn:${namespace}:`)) {\n    throw new Error(`Invalid URN for namespace ${namespace}: ${urn}`);\n  }\n\n  const type = urn.split(\":\")[2];\n  const [urnPart, queryString] = urn.split(\"?\");\n  const id = urnPart.split(\":\")[3];\n  const qs = queryString\n    ? Object.fromEntries(new URLSearchParams(queryString))\n    : {};\n\n  return {\n    type,\n    id,\n    qs,\n  };\n}\n\n/*\n * Converts a string value to a URN.\n */\nexport function asUrn(value: string, namespace: string = \"r\u00F3\"): ParsedUrn {\n  try {\n    return parseUrn(value, namespace);\n  } catch (_) {\n    return {\n      type: \"unknown\",\n      id: value,\n      qs: {},\n    };\n  }\n}\n", "/*\n * Indexed set class\n *\n * Allows you to check content membership in O(1), and lookup by key or index in O(1).\n *\n * Used to address content to unique IDs, to waste less memory during indexing.\n */\nexport class IndexedSet {\n  #idx: number;\n  #map: Map<string, number>;\n  #reverseMap: Map<number, string>;\n\n  constructor() {\n    this.#idx = 0;\n    this.#map = new Map();\n    this.#reverseMap = new Map();\n  }\n\n  map() {\n    return this.#map;\n  }\n\n  reverseMap() {\n    return this.#reverseMap;\n  }\n\n  add(value: string) {\n    if (this.#map.has(value)) {\n      return this.#map.get(value)!;\n    }\n\n    this.#map.set(value, this.#idx);\n    this.#reverseMap.set(this.#idx, value);\n    this.#idx++;\n\n    return this.#idx - 1;\n  }\n\n  getIndex(value: string): number | undefined {\n    return this.#map.get(value);\n  }\n\n  getValue(idx: number): string | undefined {\n    return this.#reverseMap.get(idx);\n  }\n\n  has(value: string): boolean {\n    return this.#map.has(value);\n  }\n}\n\nexport class Sets {\n  /*\n   * Compute the intersection of multiple numeric sets.\n   * The number of sets will be low (we're not adding ninety\n   * query parameters to these URNs) so first sort the\n   * sets in ascending size. This could be done much, much more\n   * efficiently with a dataset that allows cheap intersections though...TODO\n   */\n  static intersection<T>(sets: Set<T>[]): Set<T> {\n    if (sets.length === 0) {\n      return new Set<T>();\n    }\n\n    sets.sort((setA, setB) => {\n      return setA.size - setB.size;\n    });\n    const acc = new Set<T>(sets[0]);\n\n    for (let idx = 1; idx < sets.length; idx++) {\n      const currentSet = sets[idx];\n      for (const value of acc) {\n        if (!currentSet.has(value)) {\n          acc.delete(value);\n        }\n      }\n\n      if (acc.size === 0) {\n        break;\n      }\n    }\n\n    return acc;\n  }\n}\n", "import { Triples } from \"../index.ts\";\nimport type { IndexedTriple, Triple } from \"../types.ts\";\nimport { asUrn } from \"../urn.ts\";\nimport { IndexedSet } from \"./sets.ts\";\n\n\n/*\n * Construct an index to accelerate triple searches. Normally\n * search would be done through a linear table scan, but it can\n * be sped up by mapping each queryable term (e.g `source.id`) to\n * a set of indices of triples which match this term.\n *\n * This implementation uses IndexedSet to map strings to numbers\n * internally for better memory efficiency with long strings.\n */\nexport class Index {\n  // Internal indexed representation for memory efficiency\n  private indexedTriples: IndexedTriple[];\n\n  // String indexing sets for memory efficiency\n  private stringIndex: IndexedSet;\n\n  sourceType: Map<number, Set<number>>;\n  sourceId: Map<number, Set<number>>;\n  // note: QS uses a composite key: <key>=<value>\n  sourceQs: Map<number, Set<number>>;\n\n  relations: Map<number, Set<number>>;\n\n  targetType: Map<number, Set<number>>;\n  targetId: Map<number, Set<number>>;\n  targetQs: Map<number, Set<number>>;\n\n  constructor(triples: Triple[]) {\n    this.indexedTriples = [];\n    this.stringIndex = new IndexedSet();\n\n    this.sourceType = new Map();\n    this.sourceId = new Map();\n    this.sourceQs = new Map();\n    this.relations = new Map();\n    this.targetType = new Map();\n    this.targetId = new Map();\n    this.targetQs = new Map();\n    this.indexTriples(triples);\n  }\n\n  /*\n   * Associate each triple onto an appropriate map `Term := <id>: <value>`\n   */\n  indexTriples(triples: Triple[]) {\n    for (let idx = 0; idx < triples.length; idx++) {\n      this.indexTriple(triples[idx], idx);\n    }\n  }\n\n  /*\n   * Index a single triple at the given index position\n   */\n  private indexTriple(triple: Triple, idx: number) {\n    const parsedSource = asUrn(Triples.source(triple));\n    const relation = Triples.relation(triple);\n    const parsedTarget = asUrn(Triples.target(triple));\n\n    // Convert strings to indices using the IndexedSet\n    const sourceTypeIdx = this.stringIndex.add(parsedSource.type);\n    const sourceIdIdx = this.stringIndex.add(parsedSource.id);\n    const relationIdx = this.stringIndex.add(relation);\n    const targetTypeIdx = this.stringIndex.add(parsedTarget.type);\n    const targetIdIdx = this.stringIndex.add(parsedTarget.id);\n\n    // Store the indexed triple\n    this.indexedTriples.push([\n      this.stringIndex.add(Triples.source(triple)),\n      relationIdx,\n      this.stringIndex.add(Triples.target(triple)),\n    ]);\n\n    // source.type\n    if (!this.sourceType.has(sourceTypeIdx)) {\n      this.sourceType.set(sourceTypeIdx, new Set());\n    }\n    this.sourceType.get(sourceTypeIdx)!.add(idx);\n\n    // source.id\n    if (!this.sourceId.has(sourceIdIdx)) {\n      this.sourceId.set(sourceIdIdx, new Set());\n    }\n    this.sourceId.get(sourceIdIdx)!.add(idx);\n\n    // source.qs\n    for (const [key, val] of Object.entries(parsedSource.qs)) {\n      const qsIdx = this.stringIndex.add(`${key}=${val}`);\n      if (!this.sourceQs.has(qsIdx)) {\n        this.sourceQs.set(qsIdx, new Set());\n      }\n\n      this.sourceQs.get(qsIdx)!.add(idx);\n    }\n\n    // relation\n    if (!this.relations.has(relationIdx)) {\n      this.relations.set(relationIdx, new Set());\n    }\n    this.relations.get(relationIdx)!.add(idx);\n\n    // target.type\n    if (!this.targetType.has(targetTypeIdx)) {\n      this.targetType.set(targetTypeIdx, new Set());\n    }\n    this.targetType.get(targetTypeIdx)!.add(idx);\n\n    // target.id\n    if (!this.targetId.has(targetIdIdx)) {\n      this.targetId.set(targetIdIdx, new Set());\n    }\n    this.targetId.get(targetIdIdx)!.add(idx);\n\n    // target.qs\n    for (const [key, val] of Object.entries(parsedTarget.qs)) {\n      const qsIdx = this.stringIndex.add(`${key}=${val}`);\n      if (!this.targetQs.has(qsIdx)) {\n        this.targetQs.set(qsIdx, new Set());\n      }\n\n      this.targetQs.get(qsIdx)!.add(idx);\n    }\n  }\n\n  /*\n   * Add new triples to the index incrementally\n   */\n  add(newTriples: Triple[]) {\n    const startIdx = this.indexedTriples.length;\n\n    // Index the new triples\n    for (let idx = 0; idx < newTriples.length; idx++) {\n      this.indexTriple(newTriples[idx], startIdx + idx);\n    }\n  }\n\n  /*\n   * Get the number of triples in the index\n   */\n  get length(): number {\n    return this.indexedTriples.length;\n  }\n\n  /*\n   * Reconstruct the original triples from the indexed representation\n   */\n  triples(): Triple[] {\n    return this.indexedTriples.map(([sourceIdx, relationIdx, targetIdx]) => [\n      this.stringIndex.getValue(sourceIdx)!,\n      this.stringIndex.getValue(relationIdx)!,\n      this.stringIndex.getValue(targetIdx)!,\n    ]);\n  }\n\n  /*\n   * Get a specific triple by index\n   */\n  getTriple(index: number): Triple | undefined {\n    if (index < 0 || index >= this.indexedTriples.length) {\n      return undefined;\n    }\n\n    const [sourceIdx, relationIdx, targetIdx] = this.indexedTriples[index];\n    return [\n      this.stringIndex.getValue(sourceIdx)!,\n      this.stringIndex.getValue(relationIdx)!,\n      this.stringIndex.getValue(targetIdx)!,\n    ];\n  }\n\n  /*\n   * Helper methods to convert string keys to indices for external API compatibility\n   */\n\n  getSourceTypeSet(type: string): Set<number> | undefined {\n    const typeIdx = this.stringIndex.getIndex(type);\n    return typeIdx !== undefined ? this.sourceType.get(typeIdx) : undefined;\n  }\n\n  getSourceIdSet(id: string): Set<number> | undefined {\n    const idIdx = this.stringIndex.getIndex(id);\n    return idIdx !== undefined ? this.sourceId.get(idIdx) : undefined;\n  }\n\n  getSourceQsSet(key: string, val: string): Set<number> | undefined {\n    const qsIdx = this.stringIndex.getIndex(`${key}=${val}`);\n    return qsIdx !== undefined ? this.sourceQs.get(qsIdx) : undefined;\n  }\n\n  getRelationSet(relation: string): Set<number> | undefined {\n    const relationIdx = this.stringIndex.getIndex(relation);\n    return relationIdx !== undefined\n      ? this.relations.get(relationIdx)\n      : undefined;\n  }\n\n  getTargetTypeSet(type: string): Set<number> | undefined {\n    const typeIdx = this.stringIndex.getIndex(type);\n    return typeIdx !== undefined ? this.targetType.get(typeIdx) : undefined;\n  }\n\n  getTargetIdSet(id: string): Set<number> | undefined {\n    const idIdx = this.stringIndex.getIndex(id);\n    return idIdx !== undefined ? this.targetId.get(idIdx) : undefined;\n  }\n\n  getTargetQsSet(key: string, val: string): Set<number> | undefined {\n    const qsIdx = this.stringIndex.getIndex(`${key}=${val}`);\n    return qsIdx !== undefined ? this.targetQs.get(qsIdx) : undefined;\n  }\n}\n", "import type { Dsl, Triple, TripleObject } from \"./types.ts\";\nimport { Index } from \"./indices/index.ts\";\nimport { Sets } from \"./indices/sets.ts\";\n\n/*\n * Static methods for interacting with triples.\n */\nexport class Triples {\n  static source(triple: Triple): string {\n    return triple[0];\n  }\n\n  static relation(triple: Triple): string {\n    return triple[1];\n  }\n\n  static target(triple: Triple): string {\n    return triple[2];\n  }\n}\n\n/*\n * A searchable triple database\n *\n * Provides methods for adding, searching, and manipulating triples.\n */\nexport class TribbleDB {\n  index: Index;\n  triplesCount: number;\n\n  constructor(triples: Triple[]) {\n    this.index = new Index(triples);\n    this.triplesCount = this.index.length;\n  }\n\n  static of(triples: Triple[]): TribbleDB {\n    return new TribbleDB(triples);\n  }\n\n  static from(objects: TripleObject[]): TribbleDB {\n    const triples: Triple[] = [];\n\n    for (const obj of objects) {\n      const { id, ...relations } = obj;\n\n      for (const [relation, target] of Object.entries(relations)) {\n        if (Array.isArray(target)) {\n          for (const sub of target) {\n            triples.push([id as string, relation, sub]);\n          }\n        } else {\n          triples.push([id as string, relation, target]);\n        }\n      }\n    }\n\n    return new TribbleDB(triples);\n  }\n\n  add(triples: Triple[]): void {\n    this.index.add(triples);\n    this.triplesCount = this.index.length;\n  }\n\n  map(fn: (triple: Triple) => Triple): TribbleDB {\n    return new TribbleDB(this.index.triples().map(fn));\n  }\n\n  flatMap(fn: (triple: Triple) => Triple[]): TribbleDB {\n    const flatMappedTriples = this.index.triples().flatMap(fn) as Triple[];\n    return new TribbleDB(flatMappedTriples);\n  }\n\n  first(): Triple | undefined {\n    return this.index.length > 0 ? this.index.getTriple(0) : undefined;\n  }\n\n  triples(): Triple[] {\n    return this.index.triples();\n  }\n\n  sources(): Set<string> {\n    return new Set(\n      this.index.triples().map((triple) => Triples.source(triple)),\n    );\n  }\n\n  relations(): Set<string> {\n    return new Set(\n      this.index.triples().map((triple) => Triples.relation(triple)),\n    );\n  }\n\n  targets(): Set<string> {\n    return new Set(\n      this.index.triples().map((triple) => Triples.target(triple)),\n    );\n  }\n\n  /*\n   * Get all unique objects represented by the triples.\n   *\n   * @returns An array of unique TripleObject instances.\n   */\n  objects(): TripleObject[] {\n    const objs: Record<string, TripleObject> = {};\n\n    for (const [source, relation, target] of this.index.triples()) {\n      if (!objs[source]) {\n        objs[source] = {};\n      }\n      if (!objs[source][relation]) {\n        objs[source][relation] = target;\n      } else if (Array.isArray(objs[source][relation])) {\n        (objs[source][relation] as string[]).push(target);\n      } else {\n        objs[source][relation] = [objs[source][relation] as string, target];\n      }\n    }\n\n    const output: TripleObject[] = [];\n\n    for (const [id, obj] of Object.entries(objs)) {\n      obj.id = id;\n      output.push(obj);\n    }\n\n    return output;\n  }\n\n  /*\n   * Search all triples in the database.\n   *\n   * @param params - The search parameters.\n   * @returns A new TribbleDB instance containing the matching triples.\n   */\n  search(\n    params: { source?: Dsl; relation?: string; target?: Dsl },\n  ): TribbleDB {\n    // by default, all triples are in the intersection set. Then, we\n    // only keep the triple rows that meet the other criteria too\n    const indexes: Set<number>[] = [\n      new Set<number>(\n        Array.from({ length: this.triplesCount }, (_, index) => index),\n      ),\n    ];\n\n    const source = params.source;\n    const relation = params.relation;\n    const target = params.target;\n\n    if (source) {\n      if (source.type) {\n        const sourceTypeSet = this.index.getSourceTypeSet(source.type);\n        if (sourceTypeSet) {\n          indexes.push(sourceTypeSet);\n        } else {\n          return new TribbleDB([]);\n        }\n      }\n\n      if (source.id) {\n        const sourceIdSet = this.index.getSourceIdSet(source.id);\n        if (sourceIdSet) {\n          indexes.push(sourceIdSet);\n        } else {\n          return new TribbleDB([]);\n        }\n      }\n\n      if (source.qs) {\n        for (const [key, val] of Object.entries(source.qs)) {\n          const sourceQsSet = this.index.getSourceQsSet(key, val);\n          if (sourceQsSet) {\n            indexes.push(sourceQsSet);\n          } else {\n            return new TribbleDB([]);\n          }\n        }\n      }\n    }\n\n    if (target) {\n      if (target.type) {\n        const targetTypeSet = this.index.getTargetTypeSet(target.type);\n        if (targetTypeSet) {\n          indexes.push(targetTypeSet);\n        } else {\n          return new TribbleDB([]);\n        }\n      }\n\n      if (target.id) {\n        const targetIdSet = this.index.getTargetIdSet(target.id);\n        if (targetIdSet) {\n          indexes.push(targetIdSet);\n        } else {\n          return new TribbleDB([]);\n        }\n      }\n\n      if (target.qs) {\n        for (const [key, val] of Object.entries(target.qs)) {\n          const targetQsSet = this.index.getTargetQsSet(key, val);\n          if (targetQsSet) {\n            indexes.push(targetQsSet);\n          } else {\n            return new TribbleDB([]);\n          }\n        }\n      }\n    }\n\n    if (relation) {\n      const relationSet = this.index.getRelationSet(relation);\n      if (relationSet) {\n        indexes.push(relationSet);\n      } else {\n        return new TribbleDB([]);\n      }\n    }\n\n    const intersection = Sets.intersection(indexes);\n    const matchingTriples: Triple[] = [];\n\n    // Collect matching triples, applying predicate filters as we go\n    for (const index of intersection) {\n      const triple = this.index.getTriple(index)!;\n\n      // Apply predicate filters if present\n      if (source?.predicate || target?.predicate) {\n        const sourceMatches = source?.predicate\n          ? source.predicate(Triples.source(triple))\n          : true;\n        const targetMatches = target?.predicate\n          ? target.predicate(Triples.target(triple))\n          : true;\n\n        if (sourceMatches && targetMatches) {\n          matchingTriples.push(triple);\n        }\n      } else {\n        matchingTriples.push(triple);\n      }\n    }\n\n    return new TribbleDB(matchingTriples);\n  }\n\n  searchArray(\n    params: { source?: Dsl; relation?: string; target?: Dsl },\n  ): Triple[] {\n    return this.search(params).triples();\n  }\n}\n"],
  "mappings": "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",
  "names": ["parseUrn", "urn", "namespace", "type", "urnPart", "queryString", "id", "qs", "asUrn", "value", "IndexedSet", "#idx", "#map", "#reverseMap", "value", "idx", "Sets", "sets", "setA", "setB", "acc", "currentSet", "Index", "triples", "IndexedSet", "idx", "triple", "parsedSource", "asUrn", "Triples", "relation", "parsedTarget", "sourceTypeIdx", "sourceIdIdx", "relationIdx", "targetTypeIdx", "targetIdIdx", "key", "val", "qsIdx", "newTriples", "startIdx", "sourceIdx", "targetIdx", "index", "type", "typeIdx", "id", "idIdx", "Triples", "triple", "TribbleDB", "_TribbleDB", "triples", "Index", "objects", "obj", "id", "relations", "relation", "target", "sub", "fn", "flatMappedTriples", "objs", "source", "output", "params", "indexes", "_", "index", "sourceTypeSet", "sourceIdSet", "key", "val", "sourceQsSet", "targetTypeSet", "targetIdSet", "targetQsSet", "relationSet", "intersection", "Sets", "matchingTriples", "sourceMatches", "targetMatches"]
}
