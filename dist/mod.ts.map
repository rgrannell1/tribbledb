{
  "version": 3,
  "sources": ["../types.ts", "../predicates.ts", "../index.ts"],
  "sourcesContent": ["export type URN = string & `urn:r\u00F3:${string}`;\nexport type Thing = string | URN;\nexport type Relation = string;\nexport type Triple = [Thing, Relation, Thing];\n\nexport function isURN(thing: Thing, namespace: string = 'urn:r\u00F3'): thing is URN {\n  return typeof thing === \"string\" && thing.startsWith(`urn:${namespace}:`);\n}\n\nexport type Pattern =\n  // exact matches\n  | string\n  | // predicates on the value\n  ((val: string) => boolean);\n\nexport type TripleObject = Record<string, string | string[]>;\nexport type Predicate = (val: string) => boolean;\n", "import { Predicate } from \"./types.ts\";\n\nexport function truth(_: string) {\n  return true;\n}\n\nexport function falsity(_: string) {\n  return false;\n}\n\nexport function all(...preds: Predicate[]) {\n  return (value: string) => preds.every((pred) => pred(value));\n}\n\nexport function any(...preds: Predicate[]) {\n  return (value: string) => preds.some((pred) => pred(value));\n}\n\nexport function not(predicate: Predicate) {\n  return (value: string) => !predicate(value);\n}\n\n/*\n * URN specifics\n */\nfunction parseUrn(urn: string) {\n  if (!isUrn(urn)) {\n    throw new Error(`Invalid URN: ${urn}`);\n  }\n\n  const type = urn.split(\":\")[2];\n  const [urnPart, queryString] = urn.split(\"?\");\n  const id = urnPart.split(\":\")[3];\n  const qs = queryString\n    ? Object.fromEntries(new URLSearchParams(queryString))\n    : {};\n\n  return {\n    type,\n    id,\n    qs,\n  };\n}\n\nexport function isUrn(namespace: string = \"r\u00F3\") {\n  return (value: string) => {\n    return value.startsWith(`urn:${namespace}:`);\n  };\n}\n\nexport function isType(type: string) {\n  return (value: string) => {\n    if (!isUrn()(value)) {\n      return false;\n    }\n\n    return parseUrn(value).type === type;\n  };\n}\n\nexport function sameUrn(candidate: string) {\n  return (value: string) => {\n    if (!isUrn()(value) || !isUrn()(candidate)) {\n      return false;\n    }\n\n    const parsedValue = parseUrn(value);\n    const parsedCandidate = parseUrn(candidate);\n\n    return parsedValue.id === parsedCandidate.id &&\n      parsedValue.type === parsedCandidate.type;\n  };\n}\n\nexport function sameType(candidate: string) {\n  return (value: string) => {\n    if (!isUrn()(value) || !isUrn()(candidate)) {\n      return false;\n    }\n\n    const parsedValue = parseUrn(value);\n    const parsedCandidate = parseUrn(candidate);\n\n    return parsedValue.type === parsedCandidate.type;\n  };\n}\n\nexport function hasParameter(name: string, paramValue?: string) {\n  return (value: string) => {\n    if (!isUrn()(value)) {\n      return false;\n    }\n\n    const parsed = parseUrn(value);\n    if (!Object.prototype.hasOwnProperty.call(parsed.qs, name)) {\n      return false;\n    }\n\n    if (typeof paramValue === 'undefined') {\n      return true;\n    }\n\n    return parsed.qs[name] === paramValue;\n  }\n}", "import { Pattern, Triple, TripleObject } from \"./types.ts\";\nimport { truth } from \"./predicates.ts\";\n\n/*\n * Static methods for interacting with triples.\n */\nexport class Triples {\n  static source(triple: Triple): string {\n    return triple[0];\n  }\n\n  static relation(triple: Triple): string {\n    return triple[1];\n  }\n\n  static target(triple: Triple): string {\n    return triple[2];\n  }\n}\n\nexport class TribbleDB {\n  #triples: Triple[] = [];\n\n  constructor(triples: Triple[] = []) {\n    this.#triples = triples;\n  }\n\n  static of(triples: Triple[]): TribbleDB {\n    return new TribbleDB(triples);\n  }\n\n  static from(objects: TripleObject[]): TribbleDB {\n    const triples: Triple[] = [];\n\n    for (const obj of objects) {\n      const { id, ...relations } = obj;\n\n      for (const [relation, target] of Object.entries(relations)) {\n        if (Array.isArray(target)) {\n          for (const sub of target) {\n            triples.push([id as string, relation, sub]);\n          }\n        } else {\n          triples.push([id as string, relation, target]);\n        }\n      }\n    }\n\n    return new TribbleDB(triples);\n  }\n\n  add(triples: Triple[]): void {\n    this.#triples.push(...triples);\n  }\n\n  map(\n    fn: (triple: Triple) => Triple,\n  ): TribbleDB {\n    return new TribbleDB(this.#triples.map(fn));\n  }\n\n  flatMap(\n    fn: (triple: Triple) => Triple[],\n  ): TribbleDB {\n    return new TribbleDB(this.#triples.flatMap(fn) as Triple[]);\n  }\n\n  /*\n   * Test if a pattern matches a source/relation/target value.\n   *\n   *\n   */\n  #matches(pattern: Pattern, value: string): boolean {\n    if (typeof pattern === \"string\") {\n      return pattern === value;\n    } else if (typeof pattern === \"function\") {\n      return pattern(value);\n    }\n    return false;\n  }\n\n  /**\n   * Finds triples in the database that match the given patterns.\n   *\n   * @param source   - The pattern for the source of the triple.\n   * @param relation - The pattern for the relation of the triple.\n   * @param target   - The pattern for the target of the triple.\n   *\n   * @returns A new TribbleDB instance containing matching triples.\n   */\n  filter(\n    source: Pattern = truth,\n    relation: Pattern = truth,\n    target: Pattern = truth,\n  ) {\n    return new TribbleDB(this.#triples.filter((triple) => {\n      return this.#matches(source, Triples.source(triple)) &&\n        this.#matches(relation, Triples.relation(triple)) &&\n        this.#matches(target, Triples.target(triple));\n    }));\n  }\n\n  find(\n    source: Pattern = truth,\n    relation: Pattern = truth,\n    target: Pattern = truth,\n  ): TribbleDB {\n    const result = this.#triples.find((triple) => {\n      return this.#matches(source, Triples.source(triple)) &&\n        this.#matches(relation, Triples.relation(triple)) &&\n        this.#matches(target, Triples.target(triple));\n    });\n\n    if (result) {\n      return new TribbleDB([result]);\n    }\n\n    return new TribbleDB([]);\n  }\n\n  exists(\n    source: Pattern = truth,\n    relation: Pattern = truth,\n    target: Pattern = truth,\n  ): boolean {\n    return this.#triples.some((triple) => {\n      return this.#matches(source, Triples.source(triple)) &&\n        this.#matches(relation, Triples.relation(triple)) &&\n        this.#matches(target, Triples.target(triple));\n    });\n  }\n\n  hasSource(source: Pattern): boolean {\n    return this.#triples.some((triple) =>\n      this.#matches(source, Triples.source(triple))\n    );\n  }\n\n  hasRelation(relation: Pattern): boolean {\n    return this.#triples.some((triple) =>\n      this.#matches(relation, Triples.relation(triple))\n    );\n  }\n\n  hasTarget(target: Pattern): boolean {\n    return this.#triples.some((triple) =>\n      this.#matches(target, Triples.target(triple))\n    );\n  }\n\n  first(): Triple | undefined {\n    return this.#triples.length > 0 ? this.#triples[0] : undefined;\n  }\n\n  triples(): Triple[] {\n    return this.#triples;\n  }\n  sources(): Set<string> {\n    return new Set(this.#triples.map((triple) => Triples.source(triple)));\n  }\n\n  relations(): Set<string> {\n    return new Set(this.#triples.map((triple) => Triples.relation(triple)));\n  }\n\n  targets(): Set<string> {\n    return new Set(this.#triples.map((triple) => Triples.target(triple)));\n  }\n\n  objects(): TripleObject[] {\n    const objs: Record<string, TripleObject> = {};\n\n    for (const [source, relation, target] of this.#triples) {\n      if (!objs[source]) {\n        objs[source] = {};\n      }\n      if (!objs[source][relation]) {\n        objs[source][relation] = target;\n      } else if (Array.isArray(objs[source][relation])) {\n        (objs[source][relation] as string[]).push(target);\n      } else {\n        objs[source][relation] = [objs[source][relation] as string, target];\n      }\n    }\n\n    const output: TripleObject[] = [];\n\n    for (const [id, obj] of Object.entries(objs)) {\n      obj.id = id;\n      output.push(obj);\n    }\n\n    return output;\n  }\n}\n"],
  "mappings": "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",
  "names": ["isURN", "thing", "namespace", "truth", "_", "falsity", "all", "preds", "value", "pred", "any", "not", "predicate", "parseUrn", "urn", "isUrn", "type", "urnPart", "queryString", "id", "qs", "namespace", "isType", "sameUrn", "candidate", "parsedValue", "parsedCandidate", "sameType", "hasParameter", "name", "paramValue", "parsed", "Triples", "triple", "TribbleDB", "_TribbleDB", "#triples", "triples", "objects", "obj", "id", "relations", "relation", "target", "sub", "fn", "#matches", "pattern", "value", "source", "truth", "result", "objs", "output"]
}
